# Configurable aichat command variables
AI_CHAT_COMMAND=$(which aichat 2>/dev/null)
AI_EXECUTE=("$AI_CHAT_COMMAND" "-e")
AI_CHAT="$AI_CHAT_COMMAND"
# Use aichat to handle unknown commands
command_not_found_handler() {
   $AI_EXECUTE "$@"
}

# Explain a command using aichat
explain() {
    $AI_CHAT "$@"
}

# Same as explain, but allows 'explain:' syntax
explain:() {
    $AI_CHAT "$@"
}

# ZLE widget: send current buffer to aichat and replace with result
_aichat_zsh() {
    
    if [[ -n "$BUFFER" ]]; then
        local _old=$BUFFER
        BUFFER+="⌛"
        zle -I && zle redisplay
        if [[ "$(uname)" == "Darwin" ]]; then
            BUFFER=$(echo $AI_EXECUTE "$_old")
        else
            BUFFER=$($AI_EXECUTE "$_old")
        fi
        zle end-of-line
    fi
}
zle -N _aichat_zsh

# Generate a commit message using aichat and git diff
ai_commit_msg() {
    $AI_CHAT "generate a commit message for the following $(git diff)"
}

# ZLE widget for ai_commit_msg (menu-based file selection with "All" option)
_ai_commit_msg_zsh() {
    # Use local -a for arrays
    local -a files_array # Declare files_array as an array
    local files_string tmpfile msg changes # files_string will hold the space-separated list initially

    # buffer equals an hourglass
    BUFFER="⌛ Generating commit message..."
    zle -I && zle redisplay

    # Get list of potentially changed files (Modified, Added, Renamed, Copied, Untracked)
    local git_files_list
    git_files_list=$(git ls-files --others --exclude-standard --modified --deleted | sort -u) # Get candidate files

    if [[ -z "$git_files_list" ]]; then
        zle -M "No files found to commit."
        # Reset buffer or provide feedback
        BUFFER=""
        zle -I && zle redisplay
        return 1
    fi

    # Use fzf or prompt for file selection
    if command -v fzf >/dev/null 2>&1; then
        # Prepend "All files" option for fzf
        local fzf_input
        fzf_input="All files (select this to include all listed files)\n$git_files_list"
        files_string=$(echo -e "$fzf_input" | fzf -m --prompt="Select files for commit (or 'All files'): " --header="TAB to select, ENTER to confirm")
        
        if [[ -z "$files_string" ]]; then
           BUFFER="" # Clear hourglass
           zle -I && zle redisplay
           zle -M "No files selected."
           return 1
        fi

        if [[ "$files_string" == "All files (select this to include all listed files)" ]]; then
    
            # If "All files" is selected (and it's the only selection for simplicity)
            # or if it's part of multiple selections, we treat it as "all".
            # For multi-select, if "All files" is present, we take all.
                 files_array=("${(@f)git_files_list}")
            else
                 files_array=("${(@f)files_string}")
            fi
    else
        # Fallback: Simple prompt (less user-friendly for many files)
        zle -M "Enter files to include (space-separated from list above, or type 'all'):"
        read -r "files_string?Files: "
        
        if [[ -z "$files_string" ]]; then
           BUFFER="" # Clear hourglass
           zle -I && zle redisplay
           zle -M "No files entered."
           return 1
        fi

        if [[ "$files_string" == "all" ]]; then
            files_array=("${(@f)git_files_list}")
        else
            # Split the space-separated string into the array using the 'z' flag for shell parsing
            files_array=("${(z)files_string}")
        fi
    fi

    # Check if the array is actually empty after splitting (e.g., user just hit Enter)
    if [[ ${#files_array[@]} -eq 0 ]]; then
        BUFFER="" # Clear hourglass
        zle -I && zle redisplay
        zle -M "No files selected/entered."
        return 1
    fi

    tmpfile=$(mktemp /tmp/ai-commit-msg.XXXXXX)
    # Add only the selected files to staging
    # Ensure files_array elements are correctly passed to git add
    # If an element is "All files (select this to include all listed files)", it should not be passed to git add.
    # This is handled by the logic above which populates files_array with actual file names.
    git add -- "${files_array[@]}"


    # Debugging: Use the array correctly
    # Use print -r -- to safely print array elements, one per line typically
    # print -r -- "Selected files array:" "${files_array[@]}"


    # Default 'git diff' is unstaged changes in working dir vs index.
    # Use the array expansion "${files_array[@]}"
    
    
    changes=$(git diff --cached -- "${files_array[@]}")
    added_files=$(git diff --cached --name-only --diff-filter=A -- "${files_array[@]}") # Ensure diff is also scoped

    # Check if changes are empty *before* calling AI
    if [[ -z "$changes" && -z "$added_files" ]]; then
        # Option 2: Proceed (AI might still generate a generic message)
        print -r -- "Warning: No changes or added files detected via 'git diff' for selected files."
    fi

    # Ensure $AI_CHAT is defined and executable
    if ! command -v "$AI_CHAT" >/dev/null 2>&1; then
       set +x
       BUFFER="" # Clear hourglass
       zle -I && zle redisplay
       zle -M "Error: AI command '$AI_CHAT' not found or not executable."
       rm -f $tmpfile # Clean up
       trap - INT TERM EXIT # Remove trap
       return 1
    fi

    # Call the AI, quoting the changes variable
    msg="$($AI_CHAT "generate a short, concise and accurate commit message (using conventional commits format, plain text only, no markdown ticks) for the following changes: $changes, added files: $added_files")"
    # Check if AI returned an empty message
    if [[ -z "$msg" ]]; then
        BUFFER="" # Clear hourglass
        zle -I && zle redisplay
        zle -M "Warning: AI returned an empty commit message."
        # Decide: continue with empty message or abort? Let's continue for now.
    fi


    # Write message to temp file
    echo "$msg" > "$tmpfile"

    # Add the selected files using the array
    # This correctly handles filenames with spaces or special characters

    # Set the buffer for the commit command
    BUFFER="git commit -F $tmpfile"
    zle end-of-line # Move cursor to the end

}

# Make the function available as a widget
zle -N _ai_commit_msg_zsh

# Optional: Bind it to a key sequence (e.g., Alt+C)
# bindkey '^[c' _ai_commit_msg_zsh


# Keybindings for _aichat_zsh:
#   Alt-e in emacs mode, vi insert mode, and vi command mode
bindkey '\ee' _aichat_zsh
bindkey -M viins '\ee' _aichat_zsh
bindkey -M vicmd '\ee' _aichat_zsh

# Keybinding for ai_commit_msg:
#   Alt-g in emacs mode, vi insert mode, and vi command mode
bindkey '\eg' _ai_commit_msg_zsh
bindkey -M viins '\eg' _ai_commit_msg_zsh
bindkey -M vicmd '\eg' _ai_commit_msg_zsh

